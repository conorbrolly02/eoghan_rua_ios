
name: iOS Build & Sign (BeeWare Briefcase)

on:
  workflow_dispatch:

jobs:
  build-ios:
    runs-on: macos-latest

    env:
      BUNDLE_ID: ie.eoghanrua.eoghan-rua-team-selector

    steps:
      # 1) Checkout
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Python + Briefcase
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Briefcase
        run: |
          python -m pip install --upgrade pip
          pip install briefcase

      # 3) Create & build with Briefcase
      - name: Create iOS Project
        run: briefcase create iOS

      - name: Build iOS App
        run: briefcase build iOS

      # 4) Locate Xcode dir produced by Briefcase (build/<app>/ios/xcode)
      - name: Locate Xcode directory
        id: xcode
        run: |
          set -euo pipefail
          APP_DIR=$(find build -type d -name "xcode" | head -n 1)
          if [ -z "$APP_DIR" ]; then
            echo "ERROR: Xcode directory not found under build/"
            exit 1
          fi
          echo "Found Xcode dir: $APP_DIR"
          echo "APP_DIR=$APP_DIR" >> $GITHUB_OUTPUT

      # 5) Determine scheme from the .app name
      - name: Determine scheme
        id: scheme
        run: |
          set -euo pipefail
          APP_PATH=$(find "${{ steps.xcode.outputs.APP_DIR }}" -type d -name "*.app" | head -n 1)
          if [ -z "$APP_PATH" ]; then
            echo "ERROR: No .app found to infer scheme"
            exit 1
          fi
          SCHEME=$(basename "$APP_PATH" .app)
          echo "Using scheme: $SCHEME"
          echo "SCHEME=$SCHEME" >> $GITHUB_OUTPUT

      # 6) Install signing assets in a temporary keychain (sanity checks + legacy PKCS#12 re-export)
      - name: Set up signing
        id: signing
        env:
          IOS_CERT_BASE64: ${{ secrets.IOS_CERT_BASE64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISION_PROFILE_BASE64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
        run: |
          set -euo pipefail

          echo "Creating temp keychain…"
          KEYCHAIN="$RUNNER_TEMP/ios-signing.keychain-db"
          KEYCHAIN_PWD="$(uuidgen)"
          security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN"
          security set-keychain-settings -lut 3600 "$KEYCHAIN"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN"
          security list-keychains -d user -s "$KEYCHAIN"

          # ---- Decode original PKCS#12 and sanity-check with OpenSSL ----
          echo "$IOS_CERT_BASE64" | base64 --decode > "$RUNNER_TEMP/cert.p12"
          echo "Verifying original PKCS#12…"
          ls -lh "$RUNNER_TEMP/cert.p12"
          wc -c  "$RUNNER_TEMP/cert.p12"
          openssl pkcs12 -in "$RUNNER_TEMP/cert.p12" \
            -passin pass:"$IOS_CERT_PASSWORD" \
            -info -nokeys >/dev/null

          # ---- Convert to PEM (cert + key), then re-export as legacy PKCS#12 ----
          openssl pkcs12 -in "$RUNNER_TEMP/cert.p12" \
            -passin pass:"$IOS_CERT_PASSWORD" \
            -nodes -out "$RUNNER_TEMP/cert_and_key.pem"

          if openssl pkcs12 -export -legacy \
               -in  "$RUNNER_TEMP/cert_and_key.pem" \
               -out "$RUNNER_TEMP/cert_legacy.p12" \
               -name "Apple Distribution" \
               -passout pass:"$IOS_CERT_PASSWORD" 2>/dev/null; then
            echo "Re-exported PKCS#12 using -legacy."
          else
            echo "OpenSSL lacks -legacy; using explicit legacy algorithms…"
            openssl pkcs12 -export \
              -in  "$RUNNER_TEMP/cert_and_key.pem" \
              -out "$RUNNER_TEMP/cert_legacy.p12" \
              -name "Apple Distribution" \
              -passout pass:"$IOS_CERT_PASSWORD" \
              -certpbe PBE-SHA1-3DES -keypbe PBE-SHA1-3DES \
              -macalg sha1 -nomaciter
          fi

          echo "Importing legacy PKCS#12 into keychain…"
          security import "$RUNNER_TEMP/cert_legacy.p12" \
            -k "$KEYCHAIN" \
            -P "$IOS_CERT_PASSWORD" \
            -T /usr/bin/codesign

          # Allow codesign access
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PWD" "$KEYCHAIN"

          # Optional: list codesign identities for debugging (non-fatal)
          security find-identity -v -p codesigning "$KEYCHAIN" || true

          # ---- Provisioning profile ----
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          PROFILE_PATH="$HOME/Library/MobileDevice/Provisioning Profiles/profile.mobileprovision"
          echo "$IOS_PROVISION_PROFILE_BASE64" | base64 --decode > "$PROFILE_PATH"

          PROFILE_PLIST="$RUNNER_TEMP/profile.plist"
          /usr/bin/security cms -D -i "$PROFILE_PATH" > "$PROFILE_PLIST"
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$PROFILE_PLIST")
          TEAM_ID=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' "$PROFILE_PLIST")
          echo "Using profile: $PROFILE_NAME (Team: $TEAM_ID)"

          echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_OUTPUT
          echo "TEAM_ID=$TEAM_ID" >> $GITHUB_OUTPUT
          echo "KEYCHAIN=$KEYCHAIN" >> $GITHUB_OUTPUT

      # 7) Archive with signing
      - name: Archive iOS app
        run: |
          set -euo pipefail
          cd "${{ steps.xcode.outputs.APP_DIR }}"
          xcodebuild \
            -scheme "${{ steps.scheme.outputs.SCHEME }}" \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            DEVELOPMENT_TEAM="${{ steps.signing.outputs.TEAM_ID }}" \
            CODE_SIGN_STYLE=Manual \
            PROVISIONING_PROFILE_SPECIFIER="${{ steps.signing.outputs.PROFILE_NAME }}" \
            OTHER_CODE_SIGN_FLAGS="--keychain ${{ steps.signing.outputs.KEYCHAIN }}" \
            -archivePath EoghanRua.xcarchive \
            archive

      # 8) Create ExportOptions.plist via PlistBuddy (no XML heredoc)
      - name: Create ExportOptions.plist
        id: exportopts
        run: |
          set -euo pipefail
          PLIST="ExportOptions.plist"
          /usr/libexec/PlistBuddy -c "Add :method string ad-hoc" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :signingStyle string manual" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :teamID string ${{ steps.signing.outputs.TEAM_ID }}" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles dict" "$PLIST"
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles:${{ env.BUNDLE_ID }} string ${{ steps.signing.outputs.PROFILE_NAME }}" "$PLIST"
          echo "PLIST_PATH=$(pwd)/$PLIST" >> $GITHUB_OUTPUT
          echo "Created ExportOptions at $(pwd)/$PLIST"
          /usr/libexec/PlistBuddy -c "Print" "$PLIST"

      # 9) Export the signed IPA
      - name: Export signed IPA
        run: |
          set -euo pipefail
          cd "${{ steps.xcode.outputs.APP_DIR }}"
          xcodebuild -exportArchive \
            -archivePath EoghanRua.xcarchive \
            -exportPath export \
            -exportOptionsPlist "${{ steps.exportopts.outputs.PLIST_PATH }}"
          ls -lh export || true

      # 10) Upload the IPA
      - name: Upload signed IPA
        uses: actions/upload-artifact@v4
        with:
          name: EoghanRua-AdHoc-IPA
          path: ${{ steps.xcode.outputs.APP_DIR }}/export/*.ipa
