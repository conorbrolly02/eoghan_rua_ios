
name: iOS Build & Sign (BeeWare Briefcase)

on:
  workflow_dispatch:

jobs:
  build-ios:
    runs-on: macos-latest

    env:
      BUNDLE_ID: ie.eoghanrua.eoghan-rua-team-selector
      BRIEFCASE_VERBOSE: "1"

    steps:
      # 1) Checkout
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Python + Briefcase
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Briefcase
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install briefcase

      # 3) Print pyproject & soft sanity warning (does not fail the job)
      - name: Print pyproject & soft-check expected fields
        run: |
          set -euo pipefail
          PY="pyproject.toml"
          echo "----- pyproject.toml (first 120 lines) -----"
          sed -n '1,120p' "$PY" || true
          echo "----- soft sanity check (WARN only) -----"
          WARN=0
          grep -E '^\[tool\.briefcase\.app\.eoghan_rua_team_selector\]' "$PY" >/dev/null || { echo "::warning::Missing [tool.briefcase.app.eoghan_rua_team_selector] section"; WARN=1; }
          grep -E '^[[:space:]]*module[[:space:]]*='   "$PY" | grep -F 'eoghan_rua_team_selector.app' >/dev/null || { echo "::warning::Missing/invalid module=eoghan_rua_team_selector.app"; WARN=1; }
          grep -E '^[[:space:]]*requires[[:space:]]*=' "$PY" >/dev/null || { echo "::warning::Missing requires=[...] list"; WARN=1; }
          grep -E -i 'std-nslog' "$PY" >/dev/null || { echo "::warning::std-nslog not present in requires (Python stdout/stderr won't hit syslog)"; WARN=1; }
          grep -E '^[[:space:]]*icon[[:space:]]*='    "$PY" >/dev/null || { echo "::warning::Missing icon=... (set to assets/icon.png)"; WARN=1; }
          grep -E '^[[:space:]]*splash[[:space:]]*='  "$PY" >/dev/null || { echo "::warning::Missing splash=... (set to assets/splash.png)"; WARN=1; }
          grep -E '^[[:space:]]*resources[[:space:]]*=' "$PY" >/dev/null || { echo "::warning::Missing resources=[...] (should include assets/crest.png)"; WARN=1; }
          for f in assets/icon.png assets/splash.png assets/crest.png; do
            test -f "$f" || { echo "::warning::Missing file: $f"; WARN=1; }
          done
          if [ "$WARN" -eq 1 ]; then
            echo "::notice::Sanity check warnings detected above. Build will continue; ensure you commit pyproject/assets fixes."
          else
            echo "pyproject + assets look OK"
          fi

      # 4) Create project (idempotent) & UPDATE metadata+requirements so icon/splash/deps/resources refresh
      - name: Create iOS project & update metadata/requirements
        run: |
          set -euo pipefail
          briefcase create iOS || true
          # -d refreshes Info.plist, icons, splash, etc.; -r refreshes Python deps (incl. std-nslog)
          briefcase update iOS -d -r

      # 5) Build iOS App
      - name: Build iOS App
        run: |
          set -euo pipefail
          briefcase build iOS

      # 6) Locate Xcode dir produced by Briefcase (build/<app>/ios/xcode)
      - name: Locate Xcode directory
        id: xcode
        run: |
          set -euo pipefail
          APP_DIR=$(find build -type d -name "xcode" | head -n 1)
          if [ -z "$APP_DIR" ]; then
            echo "ERROR: Xcode directory not found under build/"
            exit 1
          fi
          echo "Found Xcode dir: $APP_DIR"
          echo "APP_DIR=$APP_DIR" >> $GITHUB_OUTPUT

      # 7) Inspect AppIcon asset (prove bee icon replaced)
      - name: Inspect AppIcon asset catalog (pre-archive)
        run: |
          set -euo pipefail
          ICONSET=$(find "${{ steps.xcode.outputs.APP_DIR }}" -type d -path "*/Assets.xcassets/AppIcon.appiconset" | head -n 1 || true)
          if [ -n "$ICONSET" ]; then
            echo "AppIcon.appiconset: $ICONSET"
            ls -l "$ICONSET" || true
            echo "----- AppIcon Contents.json (first 200 lines) -----"
            sed -n '1,200p' "$ICONSET/Contents.json" || true
          else
            echo "::warning::AppIcon.appiconset not found; Briefcase may still be using default icon."
          fi

      # 8) Determine scheme from the .app name
      - name: Determine scheme
        id: scheme
        run: |
          set -euo pipefail
          APP_PATH=$(find "${{ steps.xcode.outputs.APP_DIR }}" -type d -name "*.app" | head -n 1)
          if [ -z "$APP_PATH" ]; then
            echo "ERROR: No .app found to infer scheme"
            exit 1
          fi
          SCHEME=$(basename "$APP_PATH" .app)
          echo "Using scheme: $SCHEME"
          echo "SCHEME=$SCHEME" >> $GITHUB_OUTPUT

      # 9) Signing assets (legacy PKCS#12 import + profile UUID)
      - name: Set up signing
        id: signing
        env:
          IOS_CERT_BASE64: ${{ secrets.IOS_CERT_BASE64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISION_PROFILE_BASE64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
        run: |
          set -euo pipefail

          echo "Creating temp keychain…"
          KEYCHAIN="$RUNNER_TEMP/ios-signing.keychain-db"
          KEYCHAIN_PWD="$(uuidgen)"
          security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN"
          security set-keychain-settings -lut 3600 "$KEYCHAIN"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN"
          security list-keychains -d user -s "$KEYCHAIN"

          echo "$IOS_CERT_BASE64" | base64 --decode > "$RUNNER_TEMP/cert.p12"
          openssl pkcs12 -in "$RUNNER_TEMP/cert.p12" -passin pass:"$IOS_CERT_PASSWORD" -info -nokeys >/dev/null

          openssl pkcs12 -in "$RUNNER_TEMP/cert.p12" -passin pass:"$IOS_CERT_PASSWORD" -nodes -out "$RUNNER_TEMP/cert_and_key.pem"
          if openssl pkcs12 -export -legacy \
                -in "$RUNNER_TEMP/cert_and_key.pem" \
                -out "$RUNNER_TEMP/cert_legacy.p12" \
                -name "Apple Distribution" \
                -passout pass:"$IOS_CERT_PASSWORD" 2>/dev/null; then
            echo "Re-exported PKCS#12 using -legacy."
          else
            echo "OpenSSL lacks -legacy; using explicit legacy algorithms…"
            openssl pkcs12 -export \
              -in "$RUNNER_TEMP/cert_and_key.pem" \
              -out "$RUNNER_TEMP/cert_legacy.p12" \
              -name "Apple Distribution" \
              -passout pass:"$IOS_CERT_PASSWORD" \
              -certpbe PBE-SHA1-3DES -keypbe PBE-SHA1-3DES \
              -macalg sha1 -nomaciter
          fi

          security import "$RUNNER_TEMP/cert_legacy.p12" -k "$KEYCHAIN" -P "$IOS_CERT_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PWD" "$KEYCHAIN"
          security find-identity -v -p codesigning "$KEYCHAIN" || true

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          PROFILE_PATH="$HOME/Library/MobileDevice/Provisioning Profiles/profile.mobileprovision"
          echo "$IOS_PROVISION_PROFILE_BASE64" | base64 --decode > "$PROFILE_PATH"

          PROFILE_PLIST="$RUNNER_TEMP/profile.plist"
          /usr/bin/security cms -D -i "$PROFILE_PATH" > "$PROFILE_PLIST"
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$PROFILE_PLIST")
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$PROFILE_PLIST")
          TEAM_ID=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' "$PROFILE_PLIST")
          echo "Using profile: $PROFILE_NAME ($PROFILE_UUID) Team: $TEAM_ID"

          echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_OUTPUT
          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_OUTPUT
          echo "TEAM_ID=$TEAM_ID" >> $GITHUB_OUTPUT
          echo "KEYCHAIN=$KEYCHAIN" >> $GITHUB_OUTPUT

      # 10) Archive with Distribution identity + profile
      - name: Archive iOS app
        run: |
          set -euo pipefail
          cd "${{ steps.xcode.outputs.APP_DIR }}"
          xcodebuild \
            -scheme "${{ steps.scheme.outputs.SCHEME }}" \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            DEVELOPMENT_TEAM="${{ steps.signing.outputs.TEAM_ID }}" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE_SPECIFIER="${{ steps.signing.outputs.PROFILE_NAME }}" \
            PROVISIONING_PROFILE="${{ steps.signing.outputs.PROFILE_UUID }}" \
            OTHER_CODE_SIGN_FLAGS="--keychain ${{ steps.signing.outputs.KEYCHAIN }}" \
            -archivePath EoghanRua.xcarchive \
            archive

      # 11) Re-sign nested code → embed profile → re-sign app LAST
      - name: Finalize signing order (frameworks → embed profile → app)
        run: |
          set -euo pipefail
          APP="${{ steps.xcode.outputs.APP_DIR }}/EoghanRua.xcarchive/Products/Applications/${{ steps.scheme.outputs.SCHEME }}.app"
          KEYCHAIN="${{ steps.signing.outputs.KEYCHAIN }}"
          IDENTITY_HASH=$(security find-identity -v -p codesigning "$KEYCHAIN" | awk '/Apple Distribution/ {print $2; exit}')
          if [ -z "$IDENTITY_HASH" ]; then
            echo "ERROR: Apple Distribution identity not found"
            exit 1
          fi
          ENT_APP="$RUNNER_TEMP/app_ents.plist"
          codesign -d --entitlements :- "$APP" > "$ENT_APP" 2>/dev/null || true

          find "$APP/Frameworks" -maxdepth 1 -type d -name "*.framework" 2>/dev/null | while read -r FW; do
            echo "  sign $FW"
            codesign --force --keychain "$KEYCHAIN" --sign "$IDENTITY_HASH" "$FW"
          done

          while IFS= read -r F; do
            if file "$F" | grep -q "Mach-O"; then
              echo "  sign $F"
              codesign --force --keychain "$KEYCHAIN" --sign "$IDENTITY_HASH" "$F"
            fi
          done < <(find "$APP" -type f \( -name "*.dylib" -o -name "*.so" -o -perm -111 \) 2>/dev/null)

          cp "$HOME/Library/MobileDevice/Provisioning Profiles/profile.mobileprovision" "$APP/embedded.mobileprovision"
          codesign --force --keychain "$KEYCHAIN" --sign "$IDENTITY_HASH" --entitlements "$ENT_APP" "$APP"

      # 12) Verify signatures and crest presence (archive)
      - name: Verify code signatures (archive) & crest resource
        run: |
          set -euo pipefail
          APP="${{ steps.xcode.outputs.APP_DIR }}/EoghanRua.xcarchive/Products/Applications/${{ steps.scheme.outputs.SCHEME }}.app"
          codesign -vvv --deep --strict "$APP"
          if [ -f "$APP/resources/crest.png" ]; then
            echo "OK: crest.png found under resources/"
          else
            echo "::warning::crest.png not found under resources/ (check pyproject resources= and code path)"
          fi

      # 13) Manual IPA packaging (avoid exportArchive re-touching)
      - name: Package IPA manually
        id: manualipa
        run: |
          set -euo pipefail
          APP_ROOT="${{ steps.xcode.outputs.APP_DIR }}/EoghanRua.xcarchive/Products/Applications"
          OUT="${{ steps.xcode.outputs.APP_DIR }}/manual_export"
          mkdir -p "$OUT/Payload"
          cp -R "$APP_ROOT/${{ steps.scheme.outputs.SCHEME }}.app" "$OUT/Payload/"
          (cd "$OUT" && zip -qry "EoghanRua-AdHoc-Manual.ipa" Payload)
          echo "IPA_PATH=$OUT/EoghanRua-AdHoc-Manual.ipa" >> $GITHUB_OUTPUT
          ls -lh "$OUT"

      # 14) Verify deep signature inside the IPA (final safety)
      - name: Verify IPA content signatures
        run: |
          set -euo pipefail
          TMPDIR=$(mktemp -d)
          cp "${{ steps.manualipa.outputs.IPA_PATH }}" "$TMPDIR/app.ipa"
          cd "$TMPDIR"
          unzip -q app.ipa
          APP="Payload/${{ steps.scheme.outputs.SCHEME }}.app"
          codesign -vvv --deep --strict "$APP"
          if [ -f "$APP/resources/crest.png" ]; then
            echo "OK: crest.png present inside IPA resources/"
          else
            echo "::warning::crest.png missing inside IPA resources/"
          fi

      # 15) Upload IPA
      - name: Upload IPA (Manual)
        uses: actions/upload-artifact@v4
        with:
          name: EoghanRua-AdHoc-IPA-Manual
          path: ${{ steps.manualipa.outputs.IPA_PATH }}
