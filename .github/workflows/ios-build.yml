
name: iOS Build & Sign (BeeWare Briefcase)

on:
  workflow_dispatch:

jobs:
  build-ios:
    runs-on: macos-latest

    env:
      BUNDLE_ID: ie.eoghanrua.eoghan-rua-team-selector
      BRIEFCASE_VERBOSE: "1"

    steps:
      # 1) Checkout
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Python + Briefcase
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Briefcase + Pillow (for icon rendering)
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install briefcase Pillow

      # 3) Soft sanity check pyproject + assets (WARN only; build continues)
      - name: Print pyproject & soft-check expected fields
        run: |
          set -euo pipefail
          PY="pyproject.toml"
          echo "----- pyproject.toml (first 160 lines) -----"
          sed -n '1,160p' "$PY" || true

          echo "----- soft sanity check (WARN only) -----"
          WARN=0
          grep -E '^\[tool\.briefcase\.app\.eoghan_rua_team_selector\]' "$PY" >/dev/null || { echo "::warning::Missing [tool.briefcase.app.eoghan_rua_team_selector] section"; WARN=1; }
          grep -E '^[[:space:]]*module[[:space:]]*='   "$PY" | grep -F 'eoghan_rua_team_selector.app' >/dev/null || { echo "::warning::Missing/invalid module=eoghan_rua_team_selector.app"; WARN=1; }
          grep -E '^[[:space:]]*requires[[:space:]]*=' "$PY" >/dev/null || { echo "::warning::Missing requires=[...] list"; WARN=1; }
          grep -Ei 'std-nslog' "$PY" >/dev/null || { echo "::warning::std-nslog not present in requires (Python stdout/stderr won't hit syslog)"; WARN=1; }
          grep -E '^[[:space:]]*icon[[:space:]]*='    "$PY" >/dev/null || { echo "::warning::Missing icon=... (set to assets/icon.png)"; WARN=1; }
          grep -E '^[[:space:]]*splash[[:space:]]*='  "$PY" >/dev/null || { echo "::warning::Missing splash=... (set to assets/splash.png)"; WARN=1; }
          grep -E '^[[:space:]]*resources[[:space:]]*=' "$PY" >/dev/null || { echo "::warning::Missing resources=[...] (should include assets/crest.png)"; WARN=1; }

          # Check files if present in repo
          for f in assets/icon.png assets/splash.png assets/crest.png; do
            if [ ! -f "$f" ]; then
              echo "::warning::Missing file: $f"
              WARN=1
            fi
          done

          if [ "$WARN" -eq 1 ]; then
            echo "::notice::Sanity warnings printed above. Build will continue; please commit pyproject/assets fixes when you can."
          else
            echo "pyproject + assets look OK"
          fi

      # 4) Ensure base icon exists; if not, use crest.png. Then render all iOS icon variants.
      - name: Generate iOS AppIcon variants from base image
        run: |
          set -euo pipefail
          mkdir -p assets
          if [ ! -f assets/icon.png ]; then
            if [ -f assets/crest.png ]; then
              cp assets/crest.png assets/icon.png
              echo "No assets/icon.png found; copied assets/crest.png -> assets/icon.png"
            else
              echo "::warning::No assets/icon.png or assets/crest.png found; icon variants won't be rendered."
            fi
          fi

          python - <<'PY'
          import os
          from PIL import Image
          base = "assets/icon.png"
          sizes = [20,29,40,58,60,76,80,87,120,152,167,180,640,1024,1280,1920]
          if os.path.exists(base):
              img = Image.open(base).convert("RGBA")
              for s in sizes:
                  out = f"assets/icon.png-{s}.png"
                  img.resize((s,s), Image.LANCZOS).save(out)
                  print("Wrote", out)
          else:
              print("Base icon not found; skipping variant rendering")
          PY

      # 5) Create project & UPDATE metadata/resources/requirements with platform auto-detect
      - name: Create iOS project & update metadata/resources/requirements
        run: |
          set -euo pipefail

          # Detect whether this Briefcase supports 'iOS' or 'iOS Xcode'
          PLATFORM="iOS"
          if briefcase update "iOS" -h >/dev/null 2>&1; then
            PLATFORM="iOS"
          elif briefcase update "iOS Xcode" -h >/dev/null 2>&1; then
            PLATFORM="iOS Xcode"
          fi
          echo "Detected Briefcase platform target: $PLATFORM"

          # Create (idempotent)
          briefcase create "$PLATFORM" || true

          # Try combined update flags first; on older/newer versions, fall back gracefully
          set +e
          briefcase update "$PLATFORM" -r --update-resources
          RC=$?
          if [ $RC -ne 0 ]; then
            echo "Combined update failed with RC=$RC; trying separate refreshes..."
            briefcase update "$PLATFORM" -r || true
            briefcase update "$PLATFORM" --update-resources || true
          fi
          set -e

      # 6) Build iOS App (auto-detect platform again)
      - name: Build iOS App
        run: |
          set -euo pipefail
          if briefcase build "iOS" -h >/dev/null 2>&1; then
            briefcase build "iOS"
          else
            briefcase build "iOS Xcode"
          fi

      # 7) Locate Xcode dir produced by Briefcase
      - name: Locate Xcode directory
        id: xcode
        run: |
          set -euo pipefail
          APP_DIR=$(find build -type d -name "xcode" | head -n 1)
          if [ -z "$APP_DIR" ]; then
            echo "ERROR: Xcode directory not found under build/"
            exit 1
          fi
          echo "APP_DIR=$APP_DIR" >> $GITHUB_OUTPUT
          echo "Found Xcode dir: $APP_DIR"

      # 8) Inspect AppIcon asset (prove bee icon replaced)
      - name: Inspect AppIcon asset catalog (pre-archive)
        run: |
          set -euo pipefail
          ICONSET=$(find "${{ steps.xcode.outputs.APP_DIR }}" -type d -path "*/Assets.xcassets/AppIcon.appiconset" | head -n 1 || true)
          if [ -n "$ICONSET" ]; then
            echo "AppIcon.appiconset: $ICONSET"
            ls -l "$ICONSET" || true
            echo "----- AppIcon Contents.json (first 200 lines) -----"
            sed -n '1,200p' "$ICONSET/Contents.json" || true
          else
            echo "::warning::AppIcon.appiconset not found; Briefcase may still be using default icon."
          fi

      # 9) Determine scheme from the .app name
      - name: Determine scheme
        id: scheme
        run: |
          set -euo pipefail
          APP_PATH=$(find "${{ steps.xcode.outputs.APP_DIR }}" -type d -name "*.app" | head -n 1)
          if [ -z "$APP_PATH" ]; then
            echo "ERROR: No .app found to infer scheme"
            exit 1
          fi
          SCHEME=$(basename "$APP_PATH" .app)
          echo "SCHEME=$SCHEME" >> $GITHUB_OUTPUT
          echo "Using scheme: $SCHEME"

      # 10) Signing assets (legacy PKCS#12 import + profile UUID)
      - name: Set up signing
        id: signing
        env:
          IOS_CERT_BASE64: ${{ secrets.IOS_CERT_BASE64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISION_PROFILE_BASE64: ${{ secrets.IOS_PROVISION_PROFILE_BASE64 }}
        run: |
          set -euo pipefail

          echo "Creating temp keychain…"
          KEYCHAIN="$RUNNER_TEMP/ios-signing.keychain-db"
          KEYCHAIN_PWD="$(uuidgen)"
          security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN"
          security set-keychain-settings -lut 3600 "$KEYCHAIN"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN"
          security list-keychains -d user -s "$KEYCHAIN"

          echo "$IOS_CERT_BASE64" | base64 --decode > "$RUNNER_TEMP/cert.p12"
          openssl pkcs12 -in "$RUNNER_TEMP/cert.p12" -passin pass:"$IOS_CERT_PASSWORD" -info -nokeys >/dev/null

          openssl pkcs12 -in "$RUNNER_TEMP/cert.p12" -passin pass:"$IOS_CERT_PASSWORD" -nodes -out "$RUNNER_TEMP/cert_and_key.pem"
          if openssl pkcs12 -export -legacy \
                -in "$RUNNER_TEMP/cert_and_key.pem" \
                -out "$RUNNER_TEMP/cert_legacy.p12" \
                -name "Apple Distribution" \
                -passout pass:"$IOS_CERT_PASSWORD" 2>/dev/null; then
            echo "Re-exported PKCS#12 using -legacy."
          else
            echo "OpenSSL lacks -legacy; using explicit legacy algorithms…"
            openssl pkcs12 -export \
              -in "$RUNNER_TEMP/cert_and_key.pem" \
              -out "$RUNNER_TEMP/cert_legacy.p12" \
              -name "Apple Distribution" \
              -passout pass:"$IOS_CERT_PASSWORD" \
